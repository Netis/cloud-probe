/**
* Netis Agent REST APIs
* Netis Agent 管理平台由 **Agent**, **Daemon**, **Manager** 三个组件组成。   * Agent: 部署在用户环境中采集数据，当前支持 Packet Agent 采集网络数据   * Daemon: 部署在用户环境中通过 REST APIs 管理 Agent   * Manager: 部署在监控环境中通过 REST APIs 管理 Daemon 和 Agent 
*
* OpenAPI spec version: 0.1.0
* 
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/


#include "Daemon.h"
#include <boost/format.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/optional.hpp>
#include <net/if.h>
#include <sys/ioctl.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <ifaddrs.h>
#include <sys/socket.h>
#include <netdb.h>
#include "dep.h"
#include "glog/logging.h"


std::vector<std::shared_ptr<io::swagger::server::model::NetworkInterface>> readNetworkInterfaces(LogFileContext& ctx) {
    std::vector<std::shared_ptr<io::swagger::server::model::NetworkInterface>> interfaces;
    std::string output_buffer;
    struct ifaddrs* ifaddr;
    if (::getifaddrs(&ifaddr) == -1) {
        ctx.log("getifaddrs failed", log4cpp::Priority::ERROR);
        LOG(ERROR) << "getifaddrs failed";
        return interfaces;
    }

    std::unordered_map<std::string, std::shared_ptr<io::swagger::server::model::NetworkInterface>> name2interfaces;
    for (auto ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
        auto interface = (name2interfaces.find(ifa->ifa_name) == name2interfaces.end())
                         ? std::make_shared<io::swagger::server::model::NetworkInterface>() :
                         name2interfaces[ifa->ifa_name];
        interface->setName(ifa->ifa_name);

        if (ifa->ifa_addr) {
            if (ifa->ifa_addr->sa_family == AF_INET) {
                char host[NI_MAXHOST];
                ::memset(host, 0, NI_MAXHOST);
                if (getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in),
                                host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST) == 0) {
                    interface->getInetAddresses().push_back(host);
                }
            }
            if (ifa->ifa_addr->sa_family == AF_INET6) {
                char host[NI_MAXHOST];
                ::memset(host, 0, NI_MAXHOST);
                if (getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in6),
                                host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST) == 0) {
                    std::string text(host);
                    interface->getInetAddresses().push_back(text.substr(0, text.find("%")));
                }
            }
        }


        name2interfaces[ifa->ifa_name] = interface;
    }
    ::freeifaddrs(ifaddr);

    auto index = 0;
    for (const auto& item:name2interfaces) {
        const auto name = item.first;
        auto interface = item.second;
        interface->setIndex(index++);
        interfaces.push_back(interface);

        struct ifreq ifr;
        if (name.length() >= IF_NAMESIZE) {
            output_buffer = name + " length >= IF_NAMESIZE";
            ctx.log(output_buffer, log4cpp::Priority::ERROR);
            LOG(ERROR) << output_buffer;
            continue;
        }
        ::memcpy(ifr.ifr_name, name.c_str(), name.length());
        ifr.ifr_name[name.length()] = 0;

        std::shared_ptr<socket_t> socket(new socket_t(::socket(AF_INET, SOCK_DGRAM, 0)), [](int* handle) {
            ::close(*handle);
            delete handle;
        });

        if (*socket == -1) {
            output_buffer = name + " socket open failed";
            ctx.log(output_buffer, log4cpp::Priority::ERROR);
            LOG(ERROR) << output_buffer;
            continue;
        }
        if (::ioctl(*socket, SIOCGIFHWADDR, &ifr) != -1) {
            const auto hwaddr = reinterpret_cast<const struct sockaddr*>(&ifr.ifr_hwaddr);
            const auto mac = boost::str(boost::format("%1$02x:%2$02x:%3$02x:%4$02x:%5$02x:%6$02x")
                                        % static_cast<uint32_t>(static_cast<uint8_t>(hwaddr->sa_data[0]))
                                        % static_cast<uint32_t>(static_cast<uint8_t>(hwaddr->sa_data[1]))
                                        % static_cast<uint32_t>(static_cast<uint8_t>(hwaddr->sa_data[2]))
                                        % static_cast<uint32_t>(static_cast<uint8_t>(hwaddr->sa_data[3]))
                                        % static_cast<uint32_t>(static_cast<uint8_t>(hwaddr->sa_data[4]))
                                        % static_cast<uint32_t>(static_cast<uint8_t>(hwaddr->sa_data[5])));
            interface->setMac(mac);
        } else {
            output_buffer = boost::str(boost::format("ioctl get %1% mac  failed") % name);
            ctx.log(output_buffer, log4cpp::Priority::ERROR);
            LOG(ERROR) << output_buffer;
        }

        if (::ioctl(*socket, SIOCGIFMTU, &ifr) != -1) {
            interface->setMtu(ifr.ifr_mtu);
        } else {
            output_buffer = boost::str(boost::format("ioctl get %1% mtu failed") % name);
            ctx.log(output_buffer, log4cpp::Priority::ERROR);
            LOG(ERROR) << output_buffer;
        }

        if (::ioctl(*socket, SIOCGIFFLAGS, &ifr) != -1) {
            interface->setFlags(ifr.ifr_flags);
        } else {
            output_buffer = boost::str(boost::format("ioctl get %1% flages failed") % name);
            ctx.log(output_buffer, log4cpp::Priority::ERROR);
            LOG(ERROR) << output_buffer;
        }

    }

    return interfaces;
}

namespace io {
    namespace swagger {
        namespace server {
            namespace model {

                Daemon::Daemon() {
                    m_Id = 0L;
                    m_IdIsSet = false;
                    m_Name = "";
                    m_NameIsSet = false;
                    m_Namespace = "";
                    m_NamespaceIsSet = false;
                    m_PodName = "";
                    m_PodNameIsSet = false;
                    m_NodeName = "";
                    m_NodeNameIsSet = false;
                    m_DeployEnv = "";
                    m_DeployEnvIsSet = false;
                    m_UuidIsSet = false;
                    m_PaUUID = "";
                    m_PaUUIDIsSet = false;
                    m_RegisterRequestIpAddress = "";
                    m_RegisterRequestIpAddressIsSet = false;
                    m_Service = "";
                    m_ServiceIsSet = false;
                    m_ApiVersionIsSet = false;
                    m_SupportApiVersionsIsSet = false;
                    m_StatusIsSet = false;
                    m_StartTimestamp = 0;
                    m_StartMicroTimestamp = 0;
                    m_StartTimeIsSet = false;
                    m_LabelsIsSet = false;
                    m_SyncMode = "";
                    m_SyncModeIsSet = false;

                    m_PlatformId = "";
                    m_PlatformIdIsSet = false;

                    nics = getNetworkInterfaces();
                }

                Daemon::~Daemon() {
                }

                void Daemon::validate() {
                    // TODO: implement validation
                }

                nlohmann::json Daemon::toJson() const {
                    nlohmann::json val = nlohmann::json::object();

                    if (m_IdIsSet) {
                        val["id"] = m_Id;
                    }

                    if (m_NameIsSet) {
                        val["name"] = ModelBase::toJson(m_Name);
                    }
                    if (m_PodNameIsSet) {
                        val["podName"] = ModelBase::toJson(m_PodName);
                    }
                    if (m_NamespaceIsSet) {
                        val["namespace"] = ModelBase::toJson(m_Namespace);
                    }
                    if (m_PlatformIdIsSet) {
                        val["platformId"] = ModelBase::toJson(m_PlatformId);
                    }
                    if (m_NodeNameIsSet) {
                        val["nodeName"] = ModelBase::toJson(m_NodeName);
                    }
                    if (m_DeployEnvIsSet) {
                        val["deployEnv"] = ModelBase::toJson(m_DeployEnv);
                    }
                    if (m_RegisterRequestIpAddressIsSet) {
                        val["registerRequestIpAddress"] = ModelBase::toJson(m_RegisterRequestIpAddress);
                    }
                    if (m_UuidIsSet) {
                        val["uuid"] = ModelBase::toJson(m_Uuid);
                    }
                    if (m_PaUUIDIsSet) {
                        val["paUUID"] = ModelBase::toJson(m_PaUUID);
                    }
                    if (m_ServiceIsSet) {
                        val["service"] = ModelBase::toJson(m_Service);
                    }
                    if (m_ApiVersionIsSet) {
                        val["apiVersion"] = ModelBase::toJson(m_ApiVersion);
                    }
                    {
                        nlohmann::json jsonArray;
                        for(auto& item : m_SupportApiVersions)
                        {
                            jsonArray.push_back(ModelBase::toJson(item));
                        }
                        if(jsonArray.size())
                            val["supportApiVersions"] = jsonArray;
                    }
                    if (m_StatusIsSet) {
                        val["status"] = ModelBase::toJson(m_Status);
                    }
                    if (m_StartTimeIsSet) {
                        val["startTimestamp"] = m_StartTimestamp;
                        val["startMicroTimestamp"] = m_StartMicroTimestamp;

                    }
                    if(m_ClientVersionIsSet) {
                        val["clientVersion"] = m_ClientVersion;
                    }
                    {
                        nlohmann::json jsonArray;
                        for (auto& item : nics) {
                            jsonArray.push_back(ModelBase::toJson(item));
                        }

                        if (jsonArray.size() > 0) {
                            val["networkInterfaces"] = jsonArray;
                        }
                    }
                    {
                        nlohmann::json jsonArray;
                        for (auto& item : m_Labels) {
                            jsonArray.push_back(ModelBase::toJson(item));
                        }

                        if (jsonArray.size() > 0) {
                            val["labels"] = jsonArray;
                        }
                    }

                    if (m_SyncModeIsSet) {
                        val["syncMode"] = ModelBase::toJson(m_SyncMode);
                    }
                    return val;
                }

                void Daemon::fromJson(nlohmann::json& val) {
                    MB_FSET(id, Id)
                    MB_FSET(name, Name)
                    MB_FSET(namespace, Namespace)
                    MB_FSET(podName, PodName)
                    MB_FSET(platformId,PlatformId)
                    MB_FSET(nodeName, NodeName)
                    MB_FSET(deployEnv, DeployEnv)
                    MB_FSET(uuid, Uuid)
                    MB_FSET(paUUID,PaUUID)
                    MB_FSET(registerRequestIpAddress, RegisterRequestIpAddress)
                    MB_FSET(service, Service)
                    MB_FSET(apiVersion, ApiVersion)

                    {
                        m_SupportApiVersions.clear();
                        nlohmann::json jsonArray;

                        MB_FCHECK(supportApiVersions){
                            for(auto& item : val["supportApiVersions"]){
                                m_SupportApiVersions.push_back(item);
                            }
                        }
                    }

                    MB_FSET(status, Status)
                    MB_FSET(startTimestamp, StartTimestamp)
                    MB_FSET(startMicroTimestamp, StartMicroTimestamp)
                    {
                        m_Labels.clear();
                        nlohmann::json jsonArray;
                        MB_FCHECK(labels){
                            for (auto& item : val["labels"]) {
                                if (!item.is_null()){
                                    std::shared_ptr<Label> newItem(new Label());
                                    newItem->fromJson(item);
                                    m_Labels.push_back(newItem);
                                }
                            }
                        }
                    }
                    
                    MB_FSET(syncMode, SyncMode)
                    MB_FSET(clientVersion, ClientVersion)
                }


                int64_t Daemon::getId() const {
                    return m_Id;
                }

                void Daemon::setId(int64_t value) {
                    m_Id = value;
                    m_IdIsSet = true;
                }

                bool Daemon::idIsSet() const {
                    return m_IdIsSet;
                }

                void Daemon::unsetId() {
                    m_IdIsSet = false;
                }

                std::string Daemon::getName() const {
                    return m_Name;
                }

                void Daemon::setName(std::string value) {
                    m_Name = value;
                    m_NameIsSet = true;
                }

                bool Daemon::nameIsSet() const {
                    return m_NameIsSet;
                }

                void Daemon::unsetName() {
                    m_NameIsSet = false;
                }

                std::string Daemon::getNamespace() const {
                    return m_Namespace;
                }

                void Daemon::setNamespace(std::string value) {
                    m_Namespace = value;
                    m_NamespaceIsSet = true;
                }

                bool Daemon::namespaceIsSet() const {
                    return m_NamespaceIsSet;
                }

                void Daemon::unsetNamespace() {
                    m_NamespaceIsSet = false;
                }

                std::string Daemon::getDeployEnv() const {
                    return m_DeployEnv;
                }

                void Daemon::setDeployEnv(std::string value) {
                    m_DeployEnv = value;
                    m_DeployEnvIsSet = true;
                }

                bool Daemon::deployEnvIsSet() const {
                    return m_DeployEnvIsSet;
                }

                void Daemon::unsetDeployEnv() {
                    m_DeployEnvIsSet = false;
                }

                std::string Daemon::getPodName() const {
                    return m_PodName;
                }

                void Daemon::setPodName(std::string value) {
                    m_PodName = value;
                    m_PodNameIsSet = true;
                }

                bool Daemon::podNameIsSet() const {
                    return m_PodNameIsSet;
                }

                void Daemon::unsetPodName() {
                    m_PodNameIsSet = false;
                }

                std::string Daemon::getPlatformId() const {
                    return m_PlatformId;
                }

                void Daemon::setPlatformId(std::string value) {
                    m_PlatformId = value;
                    m_PlatformIdIsSet = true;
                }

                bool Daemon::platformIdIsSet() const {
                    return m_PlatformIdIsSet;
                }

                void Daemon::unsetPlatformId() {
                    m_PlatformIdIsSet = false;
                }

                std::string Daemon::getClientVersion() const {
                    return m_ClientVersion;
                }

                void Daemon::setClientVersion(std::string value) {
                    m_ClientVersion = value;
                    m_ClientVersionIsSet = true;
                }

                bool Daemon::clientVersionIsSet() const {
                    return m_ClientVersionIsSet;
                }

                void Daemon::unsetClientVersion() {
                    m_ClientVersionIsSet = false;
                }

                std::string Daemon::getNodeName() const {
                    return m_NodeName;
                }

                void Daemon::setNodeName(std::string value) {
                    m_NodeName = value;
                    m_NodeNameIsSet = true;
                }

                bool Daemon::nodeNameIsSet() const {
                    return m_NodeNameIsSet;
                }

                void Daemon::unsetNodeName() {
                    m_NodeNameIsSet = false;
                }

                std::string Daemon::getUuid() const {
                    return m_Uuid;
                }

                void Daemon::setUuid(std::string value) {
                    m_Uuid = value;
                    m_UuidIsSet = true;
                }

                bool Daemon::uuidIsSet() const {
                    return m_UuidIsSet;
                }

                void Daemon::unsetUuid() {
                    m_UuidIsSet = false;
                }

                std::string Daemon::getPaUUID() const {
                    return m_PaUUID;
                }

                void Daemon::setPaUUID(std::string value) {
                    m_PaUUID = value;
                    m_PaUUIDIsSet = true;
                }

                bool Daemon::paUUIDIsSet() const {
                    return m_PaUUIDIsSet;
                }

                void Daemon::unsetPaUUID() {
                    m_PaUUIDIsSet = false;
                }

                std::string Daemon::getRegisterRequestIpAddress() const {
                    return m_RegisterRequestIpAddress;
                }

                void Daemon::setRegisterRequestIpAddress(std::string value) {
                    m_RegisterRequestIpAddress = value;
                    m_RegisterRequestIpAddressIsSet = true;
                }

                bool Daemon::registerRequestIpAddressIsSet() const {
                    return m_RegisterRequestIpAddressIsSet;
                }

                void Daemon::unsetRegisterRequestIpAddress() {
                    m_RegisterRequestIpAddressIsSet = false;
                }

                std::string Daemon::getService() const {
                    return m_Service;
                }

                void Daemon::setService(std::string value) {
                    m_Service = value;
                    m_ServiceIsSet = true;
                }

                bool Daemon::serviceIsSet() const {
                    return m_ServiceIsSet;
                }

                void Daemon::unsetService() {
                    m_ServiceIsSet = false;
                }

                std::string Daemon::getApiVersion() const {
                    return m_ApiVersion;
                }

                void Daemon::setApiVersion(std::string value) {
                    m_ApiVersion = value;
                    m_ApiVersionIsSet = true;
                }

                bool Daemon::apiVersionIsSet() const {
                    return m_ApiVersionIsSet;
                }

                void Daemon::unsetApiVersion() {
                    m_ApiVersionIsSet = false;
                }

                std::string Daemon::getStatus() const {
                    return m_Status;
                }

                void Daemon::setStatus(std::string value) {
                    m_Status = value;
                    m_StatusIsSet = true;
                }

                bool Daemon::statusIsSet() const {
                    return m_StatusIsSet;
                }

                void Daemon::unsetStatus() {
                    m_StatusIsSet = false;
                }

                long Daemon::getStartTime() const {
                    return m_StartTimestamp;
                }

                void Daemon::setStartTime(struct timeval val) {
                    m_StartTimestamp = val.tv_sec;
                    m_StartMicroTimestamp = val.tv_usec;
                    m_StartTimeIsSet = true;
                }

                void Daemon::setStartTimestamp(long val) {
                    m_StartTimestamp = val;
                    m_StartTimeIsSet = true;
                }

                void Daemon::setStartMicroTimestamp(long val) {
                    m_StartMicroTimestamp = val;
                    m_StartTimeIsSet = true;
                }

                bool Daemon::startTimeIsSet() const {
                    return m_StartTimeIsSet;
                }

                void Daemon::unsetStartTime() {
                    m_StartTimeIsSet = false;
                }

                std::vector<std::shared_ptr<NetworkInterface>> Daemon::getNetworkInterfaces() {
                    return readNetworkInterfaces(m_ctx);
                }

                std::vector<std::shared_ptr<Label>>& Daemon::getLabels() {
                    return m_Labels;
                }

                bool Daemon::labelsIsSet() const {
                    return m_LabelsIsSet;
                }

                void Daemon::unsetLabels() {
                    m_LabelsIsSet = false;
                }

                int Daemon::filterNics(std::vector<std::string> & nicNames) {
                    for(auto iter=nics.begin();iter != nics.end();) {
                        if(find(nicNames.begin(),nicNames.end(),(*iter)->getName()) == nicNames.end()) {
                            iter=nics.erase(iter);
                        }else {
                            iter++;
                        }
                    }
                    return nics.size();
                }
            }
        }
    }
}

